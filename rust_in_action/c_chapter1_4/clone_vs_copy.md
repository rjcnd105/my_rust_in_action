### Cloning (std::clone::Clone)
- 느리고 비용이 비싸다
- 항상 명시적이다 (.clone())
- 원본과 다를 수 있다. 크레이트 작성자는 해당 유형의 복제가 무엇인지 정의해야한다.

### Copying (std::marker::Copy)
- 빠르고 싸다
- 암시적이다
- 항상 동일하다. 원래 값의 비트단위 복제이다

---
근데 왜 Rust 프로그래머는 항상 Copy를 사용하지 않는가?

- Copy는 무시할 수 있는 정도의 성능 영향만 있을 뿐이다. String처럼 큰 유형인 경우엔 그렇게 빠르지도 않다.
- Copy는 정확한 복사본을 만들기에 참조를 올바르게 처리할 수 없다.
  임의의 값 T를 순진하게 복사하면 두번째 소유자가 생성된다. 각 참조가 삭제될때마다 T를 삭제하려는 시도가 있기 때문에 문제가 발생할 수 있다.
- 일부 유형들은 단순 복제가 아니라 다른 것을 제공하기 위해 Clone trait을 overload한다. 예를 들어, std::rc::Rc<T>는 .clone()이 호출될 때 추가 참조를 생성하기 위해 Clone을 사용합니다.


Copy를 구현하려면 먼저 Clone을 구현해야 한다.